{
    "contents" : "#Copyright 2012 The Board of Regents of the University of Wisconsin System.\n#Contributors: Jason Shao, James McCurdy, Enhai Xie, Adam G.W. Halstead, \n#Michael H. Whitney, Nathan DiPiazza, Trey K. Sato and Yury V. Bukhman\n#\n#This file is part of GCAT.\n#\n#GCAT is free software: you can redistribute it and/or modify\n#it under the terms of the GNU Lesser General Public License as published by\n#the Free Software Foundation, either version 3 of the License, or\n#(at your option) any later version.\n#\n#GCAT is distributed in the hope that it will be useful,\n#but WITHOUT ANY WARRANTY; without even the implied warranty of\n#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#GNU Lesser General Public License for more details.\n#\n#You should have received a copy of the GNU Lesser General Public License  \n#along with GCAT.  If not, see <http://www.gnu.org/licenses/>.\n\n########################################################################\n#                                                                      #\n# Populate an output table with parameters and other useful info for   #\n#   each well in a fitted dataset.                                     #\n#                                                                      #\n########################################################################\n#\n# unlog - Should OD values be returned on the linear scale instead of log-transformed scale? \n# constant.added - For returning values on linear scale, what constant was added to ODs before the log transform? \n# reach.cutoff - what proportion of the plateau OD must tbe reached by the last valid timepoint for the curve to be marked as reaching its plateau OD?\n#\n\ntable.out = function(fitted.data.set, unlog = F, constant.added, reach.cutoff = 0.90, filename.timestamp = NULL,use.linear.param=F, use.loess=F){\n  \n  # The idea is basically to use <unlist> and <aapply> on the fitted data array in order \n  # to get one vector for each column of the output table.  \n  \n  # Get identifying information (plate, well, media and strain names)\n  plate.ID = unlist(aapply(fitted.data.set,plate.name))\n  well.ID = unlist(aapply(fitted.data.set,well.name))\n  media.ID = unlist(aapply(fitted.data.set,media.name))\n  strain.ID = unlist(aapply(fitted.data.set,strain.name))\n  # Get fit information for each well\n  #   - was it marked as empty in the plate layout?\n  #   - did the program find it to contain no growth (\"dead\")? \n  #   - was the fitting procedure successful? \n  #   - did the curve tank? if so, at what timepoint? if not, set value to \"-\"\n  \n  empty = unlist(aapply(fitted.data.set, is.empty))\n  dead  = unlist(aapply(fitted.data.set, lacks.growth))\n  fit = unlist(aapply(fitted.data.set, contains.fit))\n  tanking = unlist(aapply(fitted.data.set, tanking.start))\n  tanking[is.na(tanking) | tanking == 1 | dead] = \"-\"\n  \n  # Get calculated values for each well: specific growth, final and initial OD, fitted plateau and baseline OD, lag time, etc.\n  inflection.time = unlist(aapply(fitted.data.set, inflection.time))\n  max.spec.growth.rate = unlist(aapply(fitted.data.set, max.spec.growth.rate))\n  max.log.OD = unlist(aapply(fitted.data.set, max.log.OD))\n  inoc.log.OD = unlist(aapply(fitted.data.set, inoc.log.OD))\n  projected.growth = unlist(aapply(fitted.data.set, projected.growth))\n  projected.growth.OD = unlist(aapply(fitted.data.set, projected.growth.OD, constant.added))\n  achieved.growth = unlist(aapply(fitted.data.set, achieved.growth))\n  achieved.growth.OD = unlist(aapply(fitted.data.set, achieved.growth.OD, constant.added))\n  lag.time = unlist(aapply(fitted.data.set, lag.time))\n  shape.par = unlist(aapply(fitted.data.set, shape.par))\n  RSS = unlist(aapply(fitted.data.set, rss))\n  baseline = unlist(aapply(fitted.data.set, baseline))\n  amplitude = unlist(aapply(fitted.data.set, amplitude))\n  plateau = unlist(aapply(fitted.data.set, plateau))\n  ########################3h#############################################\n  max.spec.growth.rate.SE = unlist(aapply(fitted.data.set, max.spec.growth.rate.SE))\n  shape.par.SE = unlist(aapply(fitted.data.set, shape.par.SE))\n  lag.time.SE = unlist(aapply(fitted.data.set, lag.time.SE))\n  amplitude.SE = unlist(aapply(fitted.data.set, amplitude.SE)) # a.k.a amplitude error\n  baseline.SE = unlist(aapply(fitted.data.set, baseline.SE)) # a.k.a baseline error\n  #######################################################################\n  \n  # If the curve falls short of 90% of plateau OD by the final timepoint.\n  no.reach.plateau = !unlist(aapply(fitted.data.set, reach.plateau, cutoff = 0.9))\n  # If the fitted baseline is below zero on linear scale\n  no.reach.baseline = unlog(baseline,constant.added) < 0\n  \n  # If any of these are NA as a result of failed fits, change them to false: they don't need to be reported.  \n  no.reach.plateau[is.na(no.reach.plateau)] = F\n  no.reach.baseline[is.na(no.reach.baseline)] = F\n  # What percent of the total growth does the curve actually reach? \n  # (in case of total growth being 0, change this to 100%)\n  percent.reach = 100*((max.log.OD - inoc.log.OD) / (projected.growth))\n  percent.reach[is.infinite(percent.reach)] = 100\n  \n  # Return the name of the model (if any) that was successfully fit to the well. \n  model.used = unlist(aapply(fitted.data.set, function(well)well@model.name))\n  \n  # \"Goodness of fit\" metric\n  good.fit = unlist(aapply(fitted.data.set, model.good.fit))\n  \n  # Code the two flags: \n  flag1 = flag2 = rep(\"-\", length(tanking))\n  \n  for(i in 1:length(tanking)){\t\n    #  Flag 1 (empty/inoculated flag) possible values:\n    #   well was empty and no growth was found (E)\n    #   well was empty, but growth was found (E*)\n    #   well was inoculated but no growth was found (!)\n    #   well was inoculated and growth was found (I)\n    \n    if(empty[i] & !fit[i])\n      flag1[i] = \"E \"\n    if(empty[i] & fit[i])\n      flag1[i] = \"E*\"\n    if(!empty[i] & dead[i])\n      flag1[i] = \"! \"\n    if(!empty[i] & !dead[i])\n      flag1[i] = \"I \"\n    \n    #  Flag 2 (lower/upper asymptotes) possible values:\n    #   well did not reach lower asymptote (baseline OD) (L)\n    #   well did not reach upper asymptote (plateau OD) (U)\n    #   well did not reach either asymptote (L/U)\n    #   well reached both asymptotes (-)\n    \n    if(no.reach.baseline[i]){\n      if (no.reach.plateau[i])\n        flag2[i] = \"L/U\"\n      else\n        flag2[i] = \"L\"\n    }\n    else{\n      if (no.reach.plateau[i])\n        flag2[i] = \"U\"\n      else\n        flag2[i] = \"-\"\n    }\n    # Also use the <dead> and <empty> and <fit> to provie more info about why model fitting failed in some cases. \n    if(dead[i])\n      model.used[i] = \"<NA>: skipped\"\n    else if(!empty[i] & !fit[i])\n      model.used[i] = \"<NA>: failed\"\t\n  }\n  \n  # Flag 3: return the additional info slot. \n  flag3 = unlist(aapply(fitted.data.set, function(well){\n    if (length(well@add.info) > 0) \n      return(well@add.info)\n    else\n      return(\"\")\n  }))\n  \n  # If something is amiss with the data table use this to check on the arguments...\n  #cat(\"plate \", length(plate.ID),\" well \", length(well.ID),\" media \", length(media.ID),\" strain \", length(strain.ID),\n  #\" model \", length(model.used),\" max.spec.growth.rate\", length(max.spec.growth.rate), \"projected.growth\", length(projected.growth),\n  #\"lag.time\", length(lag.time), \"inoc.log.OD\", length(inoc.log.OD), \"good.fit\",\n  #length(good.fit),\"empty\", length(flag1),\"asymp\", length(flag2),\" tank \", length(tanking),\" reach \", length(percent.reach),\" other \", length(flag3), sep = \"\\n\")\n  # 06.28.11: Add a row number identifier for output perusal\n  row.number = 1:length(plate.ID)\n  \n  pdf.file = page.no = c()\n  # 06.29.11: Add pdf file name and page number references. Prepare timestamp for addition to output file names (for file references in last column)\n  for(i in 1:length(plate.ID)){\n    pdf.file[i] = paste(plate.ID[i], \"_plots\", filename.timestamp, \".pdf\", sep=\"\")\n    page.no[i] = (i-1) %% 96 + 2\n  }\n  # Slap it all together into a data frame.\n  if(use.loess){\n    output.core = data.frame(row = row.number, plate = plate.ID, well = well.ID, media = media.ID, strain = strain.ID, \n                             model = model.used, lag.time, inflection.time, max.spec.growth.rate, \n                             baseline, amplitude, plateau, inoc.log.OD, max.log.OD, achieved.growth,\n                             baseline.OD = unlog(baseline,constant.added), amplitude.OD = unlog(amplitude,constant.added), \n                             plateau.OD = unlog(plateau,constant.added), inoc.OD = unlog(inoc.log.OD,constant.added), \n                             max.OD = unlog(max.log.OD,constant.added), achieved.growth.OD = achieved.growth.OD,\n                             R.squared = good.fit, RSS = RSS, empty = flag1, asymp.not.reached = flag2, tank = tanking, other = flag3, pdf.file = pdf.file, page.no = page.no)\n  } else {\n    output.core = data.frame(row = row.number, plate = plate.ID, well = well.ID, media = media.ID, strain = strain.ID, \n                             model = model.used, lag.time = lag.time, lag.time.SE, inflection.time, max.spec.growth.rate, max.spec.growth.rate.SE, \n                             baseline, baseline.SE, amplitude, amplitude.SE, plateau, inoc.log.OD, max.log.OD, projected.growth, achieved.growth,\n                             baseline.OD = unlog(baseline,constant.added), amplitude.OD = unlog(amplitude,constant.added), \n                             plateau.OD = unlog(plateau,constant.added), inoc.OD = unlog(inoc.log.OD,constant.added), \n                             max.OD = unlog(max.log.OD,constant.added), projected.growth.OD = projected.growth.OD, achieved.growth.OD = achieved.growth.OD,\n                             shape.par = shape.par, shape.par.SE,\n                             R.squared = good.fit, RSS = RSS, empty = flag1, asymp.not.reached = flag2, tank = tanking, other = flag3, pdf.file = pdf.file, page.no = page.no)\n  }\n  \n  # Add units to column names\n  names2 = names(output.core)\n  names2[grep(\"time\",names2)] = sub(\"$\",\", hrs\", names2[grep(\"time\",names2)])\n  names2[grep(\"rate\",names2)] = sub(\"$\",\", log.OD/hr\", names2[grep(\"rate\",names2)])\n  log.OD.fields = c(\"baseline\", \"baseline.SE\", \"amplitude\", \"amplitude.SE\", \"plateau\", \"projected.growth\", \"achieved.growth\")\n  names2[names2 %in% log.OD.fields] = sub(\"$\", \", log.OD\", names2[names2 %in% log.OD.fields])\n  names(output.core) = names2\n    \n  # Add on any additional fields found in the plate layout. \n  all.layout.fields = sapply(fitted.data.set, function(well) unlist(well@well.info)) \n  all.layout.fields = as.data.frame(t(all.layout.fields))\n  \n  \n  addl.info = all.layout.fields[,!(names(all.layout.fields) %in% c(\"Strain\", \"Media\"))]\n  if(!is.data.frame(addl.info)){\n    addl.info = data.frame(addl.info)\n    names(addl.info) = names(all.layout.fields)[!(names(all.layout.fields) %in% c(\"Strain\", \"Media\"))] \n  }\n  \n  output = cbind(output.core,addl.info)\n  \n  return(output)\n}\n\n\n\n\n\n\n",
    "created" : 1425413247086.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2376564637",
    "id" : "6FF7DC6F",
    "lastKnownWriteTime" : 1424208623,
    "path" : "~/Documents/GCAT4/trunk/R/GCAT/R/table.output.R",
    "project_path" : "R/table.output.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}