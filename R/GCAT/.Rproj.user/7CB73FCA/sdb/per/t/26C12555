{
    "contents" : "#Copyright 2012 The Board of Regents of the University of Wisconsin System.\n#Contributors: Jason Shao, James McCurdy, Enhai Xie, Adam G.W. Halstead, \n#Michael H. Whitney, Nathan DiPiazza, Trey K. Sato and Yury V. Bukhman\n#\n#This file is part of GCAT.\n#\n#GCAT is free software: you can redistribute it and/or modify\n#it under the terms of the GNU Lesser General Public License as published by\n#the Free Software Foundation, either version 3 of the License, or\n#(at your option) any later version.\n#\n#GCAT is distributed in the hope that it will be useful,\n#but WITHOUT ANY WARRANTY; without even the implied warranty of\n#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#GNU Lesser General Public License for more details.\n#\n#You should have received a copy of the GNU Lesser General Public License  \n#along with GCAT.  If not, see <http://www.gnu.org/licenses/>.\n\n########################################################################\n#                                                                      #\n# Functions to calculate various things about wells based on fit model #\n#                                                                      #\n########################################################################\n\n# S3 generic\nlag <- function(fitted.well, ...)\n{\n  UseMethod(\"lag\")\n}\n\n#\n#  Common arguments:\n#   fitted.well - should be a well containing the results of <fit.model>, most functions will return NA if well has not been fit yet.\n#   unlog - should the value be returned on the linear scale as opposed to the log-transformed scale?\n#   constant.added - for returning values on the linear scale, what was the constant added before the log transform?\n#   digits - passed to the <round> function, default is no rounding (infinity digits)\n\nunlog = function(x, constant.added) {\n  ########################################################################\n  #   Transform values back to OD scale                                  #\n  ########################################################################\nexp(x) - constant.added\n}\n\nwell.eval = function(fitted.well, Time = NULL){\n  ########################################################################\n  #   Evaluate estimated OD at any timepoints using the fitted model     #\n  ########################################################################\n\n  # If no timepoints are provided, use the ones collected in the experiment itself.\n\tif(!is.numeric(Time))\n\t\tTime = data.from(fitted.well)$Time\n\n  #  Use of equation is deprecated.  Use nls and loess models stored in the well object instead\n  # Attempt to use <eval> with the fitted equation and parameters to get estimates for OD at the given timepoints.\n\t#output = try(eval(fitted.well@equation, fitted.well@fit.par), silent = T)\n  \n  #  Predict log.OD value(s) using nls model if present.  If no nls model, try using loess.\n  if (length(fitted.well@nls)>0) {\n    output = try(predict(fitted.well@nls,list(Time=Time)),silent=T)\n  } else if (length(fitted.well@loess)>0) {\n    output = try(predict(fitted.well@loess,Time),silent=T)\n  } else {\n    output = NA\n  }\n\n  # Return values. If OD evaluation failed for any reason, return NULL.\n  if (is.numeric(output)){\n    return(output)\n  } else {\n    return(NULL)\n\t}\n}\n\nmodel.residuals = function(fitted.well, unlog = F){\n  ########################################################################\n  #   Evaluate model residuals using the measured vs. fitted log.OD values   #\n  ########################################################################\n\tmeasured.OD = data.from(fitted.well)[,2]\n\n\t# Use <well.eval> with no Time argument to get fitted OD values at measured timepoints.\n\tpredicted.OD = well.eval(fitted.well)\n\n\t# If all values are valid, return the differences\n\tif (!is.numeric(predicted.OD))\n\t\treturn(NA)\n\telse\n    return(measured.OD - predicted.OD)\n\t}\n\ndev.from.mean = function(fitted.well){\n  ########################################################################\n  #   Evaluate deviations of log.OD values from the mean                 #\n  ########################################################################\n  measured.ODs = data.from(fitted.well,remove=T,na.rm=T)[,2]\n  \n  # Get the mean values of these measured ODs.\n  mean.ODs = mean(measured.ODs)\n  \n  if (!is.numeric(mean.ODs))\n    return (NA)\n  else\n    return (measured.ODs - mean.ODs)\n}\n\nrss = function(fitted.well){\n  #######################################################################\n  #  Get the residual sum of square.                                    #\n  #######################################################################\n  if (length(fitted.well@rss) == 0)\n    return (NA)\n  else\n    return (fitted.well@rss)\n}\n\nmodel.good.fit = function(fitted.well, digits = Inf){\n  ########################################################################\n  #   Calculate a metric for fit accuracy using squared residuals        #\n  ########################################################################\n\n  # Sum of squared residuals\n\tRSS = rss(fitted.well)\n  \n  # Total sum of squared\n  tot = sum(dev.from.mean(fitted.well)^2)\n  \n  #  Coefficient of determination\n  return (1 - RSS/tot)\n\t}\n\nparameter.text = function(fitted.well){\n  ########################################################################\n  #           Output a string with values of fitted parameters           #\n  ########################################################################\n  \n  # Get a list of fitted parameters\n  fit.par = fitted.well@fit.par\n  \n  # Giving the parameter text descriptive names.\n  if (length(fitted.well@fit.par) != 0){\n    names(fit.par)[1] = \"A\" \n    names(fit.par)[2] = \"b\" \n    names(fit.par)[3] = \"lambda\" \n    names(fit.par)[4] = \"max.spec.growth.rate\" \n   \n    if (fitted.well@model.name == \"richards sigmoid\"){ \n      names(fit.par)[5] = \"shape.par\" \n    } \n    \n    if (fitted.well@model.name == \"richards sigmoid with linear par.\"){ \n      names(fit.par)[5] = \"shape.param\" \n      names(fit.par)[6] =  \"linear term\"\n      } \n  \n    if (fitted.well@model.name == \"logistic sigmoid with linear par.\")\n      names(fit.par)[5] = \"linear.term\"\n  \n    # if loess, just show smoothing param\n    if(fitted.well@model.name == \"local polynomial regression fit.\")\n      fit.par = fitted.well@fit.par[\"smoothing parameter\"]\n  }\n \n  # Return nothing if the list is empty. Otherwise, concatenate the terms in the list with the parameter names.\n\tif(!is.list(fit.par))\n\t\treturn()\n  else{\n  \toutput = \"\"\n  \ti = 1\n  \twhile(i <= length(fit.par)){\n  \t\toutput = paste(output, names(fit.par)[i], \"=\", round(as.numeric(fit.par[i]),3), \"; \", sep = \"\")\n  \t\ti = i + 1\n      if (i %% 6 == 0)\n        output = paste(output, \"\\n\")\n  \t\t}\n  \toutput\n  \t}\n\t}\n\nmax.spec.growth.rate = function(fitted.well, digits = Inf, ...){\n  ########################################################################\n  #        Calculate maximum specific growth rate                       #\n  ########################################################################\n  if(length(fitted.well@fit.par) == 0)\n    return(NA)\n  \n  round(fitted.well@fit.par$u,digits)\n}\n\n\nplateau = function(fitted.well, digits = Inf){\n  ########################################################################\n  #        Calculate plateau log.OD from fitted parameters               #\n  ########################################################################\n  if(length(fitted.well@fit.par) == 0)\n    return(NA)\n  \n  plat = fitted.well@fit.par$A + fitted.well@fit.par$b\n  \n\tif (!is.numeric(plat)) {\n\t  plat = NA\n\t} else {\n    plat = round(plat, digits)\n\t}\n\treturn(plat)\n}\n\nbaseline = function(fitted.well, digits = Inf){\n  ########################################################################\n  #        Calculate baseline log.OD from fitted parameters              #\n  ########################################################################\n  if(length(fitted.well@fit.par) == 0)\n    return(NA)\n\n  base = fitted.well@fit.par$b\n\n  # If A (plateau OD) is invalid, return NA.\n\tif (!is.numeric(fitted.well@fit.par$A))\n\t\tbase = NA\n  # If b (baseline OD) is invalid but plateau OD was valid, return zero.\n  else if (!is.numeric(base))\n\t\tbase = 0\n\telse{\n\t\t  base = round(base, digits)\n\t\t}\n\treturn(base)\n\t}\n\ninoc.log.OD = function(fitted.well, digits = Inf){\n  ########################################################################\n  #        Calculate log.OD at inoculation from fitted parameters        #\n  ########################################################################\n\n  # Evaluated the fitted model at the inoculation timepoint (should be zero from using <start.times> from table2wells.R)\n\tif (is.null(well.eval(fitted.well)))\n\t\treturn(NA)\n  else{\n    inoc.time = fitted.well@screen.data$Time[fitted.well@start.index]\n    inoc.log.OD = well.eval(fitted.well, inoc.time)\n    if (is.na(inoc.log.OD)) inoc.log.OD = fitted.well@fit.par$b # need this in a special case: loess fits with start.index = 1 \n    return(round(inoc.log.OD, digits))\n    }\n\t}\n\nmax.log.OD = function(fitted.well, digits = Inf, ...){\n  ########################################################################\n  #        Calculate max log.OD from model fit                           #\n  ########################################################################\n\n  # Evaluated the fitted model at the final timepoint (just the last valid timepoint in the experiment)\n\tif (is.null(well.eval(fitted.well)))\n\t\treturn(NA)\n  else{\n  \treturn(round(max(well.eval(fitted.well),na.rm=T), digits))\n  }\n}\n\n\nprojected.growth = function(fitted.well,digits=Inf) {\n  ########################################################################\n  #   Calculate projected growth: plateau minus the inoculated log.OD    #\n  ########################################################################\n\tplateau(fitted.well,digits) - inoc.log.OD(fitted.well,digits)\n}\n\nprojected.growth.OD = function(fitted.well,constant.added,digits=Inf) {\n  ########################################################################\n  #   Calculate projected growth: plateau minus the inoculated log.OD    #\n  ########################################################################\n  value = unlog(plateau(fitted.well),constant.added) - unlog(inoc.log.OD(fitted.well),constant.added)\n  round(value,digits)\n}\n\n\nachieved.growth = function(fitted.well,digits=Inf) {\n  ########################################################################\n  #   Calculate achieved growth: max.log.OD minus the inoculated log.OD  #\n  ########################################################################\n  max.log.OD(fitted.well,digits) - inoc.log.OD(fitted.well,digits)\n}\n\nachieved.growth.OD = function(fitted.well,constant.added,digits=Inf) {\n  ########################################################################\n  #   Calculate projected growth: plateau minus the inoculated log.OD    #\n  ########################################################################\n  value = unlog(max.log.OD(fitted.well),constant.added) - unlog(inoc.log.OD(fitted.well),constant.added)\n  round(value,digits)\n}\n\nreach.plateau = function(fitted.well, cutoff = 0.75){\n  ########################################################################\n  # Did the curve come close to the plateau OD during the experiment?    #\n  ########################################################################\n\n  plat = plateau(fitted.well)\n  inoc = inoc.log.OD(fitted.well)\n  final = max.log.OD(fitted.well)\n\n\tif (!is.na(final)){\n    # If the plateau is the same as the OD at inoculation, return TRUE\n    if ((plat - inoc) == 0)\n      return(T)\n     # If the difference between the final OD and inoculation OD is at least a certain proportion\n     #  <cutoff> of the difference between the plateau and inoculated ODs, return TRUE.\n    else\n      return((final - inoc) / (plat - inoc) > cutoff)\n\t\t}\n\telse\n\t\treturn(T)\n\t\t# If no final OD was calculated (if curve was not fit properly) just return T.\n\t}\n\n\nlag.time = function(fitted.well, digits = Inf, ...){\n  ########################################################################\n  #              Calculate the lag time from the fitted OD               #\n  ########################################################################\n  if(length(fitted.well@fit.par) == 0)\n    return(NA)\n  \n  fitted.well@fit.par$lam\n}\n\n# new params for GCAT 4.0\n\namplitude = function(fitted.well){\n  if(length(fitted.well@fit.par) == 0)\n    return(NA)\n  \n  return(fitted.well@fit.par$A)\n}\n\nshape.par = function(fitted.well){\n    if(length(fitted.well@fit.par) == 0)\n    return(NA)\n  ifelse(is.null(fitted.well@fit.par$v), NA, fitted.well@fit.par$v)\n}\n\nmax.spec.growth.rate.SE = function(fitted.well, ...){\n  if(length(fitted.well@fit.std.err) == 0)\n    return(NA)\n  ifelse(is.null(fitted.well@fit.std.err$u), NA, fitted.well@fit.std.err$u)\n}\n\nlag.time.SE = function(fitted.well, ...){\n  if(length(fitted.well@fit.std.err) == 0)\n    return(NA)\n  ifelse(is.null(fitted.well@fit.std.err$lam), NA, fitted.well@fit.std.err$lam)\n}\n\nshape.par.SE = function(fitted.well){\n  if(length(fitted.well@fit.std.err) == 0)\n    return(NA)\n  ifelse(is.null(fitted.well@fit.std.err$v), NA, fitted.well@fit.std.err$v)\n}\n\namplitude.SE = function(fitted.well){\n  if(length(fitted.well@fit.std.err) == 0)\n    return(NA)\n  ifelse(is.null(fitted.well@fit.std.err$A), NA, fitted.well@fit.std.err$A)\n}\n\nbaseline.SE = function(fitted.well){\n  if(length(fitted.well@fit.std.err) == 0)\n    return(NA)\n  ifelse(is.null(fitted.well@fit.std.err$b), NA, fitted.well@fit.std.err$b)\n}\n\n# used to calulate the inflection.time value\ninflection.time = function(well){\n  if (length(well@loess) == 0 && length(well@nls) == 0) return(NA) # can' compute inflection time in the absence of a fit\n  data = data.from(well)\n  Time = data[,1]\n  t = seq(from = min(Time), to = max(Time), by = (max(Time)-min(Time))/1000)\n  y = well.eval(well,t)\n  if (is.null(y)) return(NA)\n  delta.t = diff(t)\n  dydt = diff(y)/delta.t\n  infl.index = which.max(dydt)\n  t[infl.index]\n}\n",
    "created" : 1425413281936.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2757150562",
    "id" : "26C12555",
    "lastKnownWriteTime" : 1428437531,
    "path" : "~/Documents/GCAT4/trunk/R/GCAT/R/fitted.calculations.R",
    "project_path" : "R/fitted.calculations.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}